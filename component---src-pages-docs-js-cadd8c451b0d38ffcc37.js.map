{"version":3,"sources":["webpack:///./src/pages/docs.js"],"names":["AboutPage","location","data","treeData","useState","edges","allMarkdownRemark","originalData","length","items","reduce","accu","node","slug","fields","title","frontmatter","parts","slice","split","prevItems","part","tmp","find","label","push","existingItem","url","className","map","child","key","href","item","props","query","render"],"mappings":"g/BAOA,IAoDMA,EAAY,SAAC,EAAUC,GAAc,IAAtBC,EAAqB,EAArBA,KACZC,EAAYC,oBAAS,WAC1B,OAtDuBC,EAsDEH,EAAKI,kBAAkBD,MAnDtB,KAFtBE,EAAeF,GAEJG,OACR,CAAEC,MAAO,IAGLF,EAAaG,QACxB,SACEC,EADF,GAWE,IAHI,IAGJ,EAHG,IALDC,KACYC,EAIX,EAJCC,OAAUD,KACKE,EAGhB,EAHCC,YAAeD,MAIbE,EAAQJ,EAAKK,MAAM,GAAI,GAAGC,MAAM,KACzBC,EAAcT,EAArBF,MAFH,iBAGQY,EAHR,QAIGC,EAAMF,EAAUG,MAAK,qBAAGC,QAAsBH,KAC9CC,EACGA,EAAIb,QACPa,EAAIb,MAAQ,KAGda,EAAM,CAAEE,MAAOH,EAAMZ,MAAO,IAC5BW,EAAUK,KAAKH,IAEjBF,EAAYE,EAAIb,OAVlB,IAAmBQ,EAAMC,MAAM,GAAI,MAAnC,aAAwC,IAYxC,IAAMQ,EAAeN,EAAUG,MAAK,qBAAGC,QAAsBP,EAAMA,EAAMT,OAAS,MAYlF,OAXIkB,GACFA,EAAaC,IAAMd,EACnBa,EAAaX,MAAQA,GAErBK,EAAUK,KAAK,CACbD,MAAOP,EAAMA,EAAMT,OAAS,GAC5BmB,IAAKd,EACLJ,MAAO,GACPM,UAGGJ,IAET,CAAEF,MAAO,KA7Ca,IAACJ,EACnBE,KAmDkC,GAKxC,OACE,YAAC,IAAD,KACE,uBAASqB,UAAS,yBAChB,kBAAIA,UAAU,mBAAd,qBACA,6BACA,mBAAKA,UAAU,qCACb,sBACGzB,EAASM,MAAMoB,KAAI,SAAAC,GAAK,OACvB,kBAAIC,IAAKD,EAAMH,KACb,iBAAGK,KAAMF,EAAMH,KAAMG,EAAMf,OAC3B,sBACGe,EAAMrB,MAAMoB,KAAI,SAAAI,GAAI,OACnB,sBACE,iBAAGD,KAAMC,EAAKN,KAAMM,EAAKlB,qBAoChC,mBAAAmB,GAAK,OAClB,YAAC,cAAD,CACEC,MAxBY,YAyBZC,OAAQ,SAAAlC,GAAI,OACV,YAACF,EAAD,aAAWC,SAAUiC,EAAMjC,SAAUC,KAAMA,GAAUgC","file":"component---src-pages-docs-js-cadd8c451b0d38ffcc37.js","sourcesContent":["\nimport { graphql, StaticQuery } from \"gatsby\"\nimport React, { useState } from 'react';\nimport DocsLayout from \"../components/layouts/docs_layout.js\"\n// Import theme \nimport \"../style/all.scss\"\n\nconst calculateTreeData = (edges) => {\n  const originalData = edges;\n\n  if (originalData.length === 0) {\n    return { items: [] };\n  }\n\n  const tree = originalData.reduce(\n    (\n      accu,\n      {\n        node: {\n          fields: { slug },\n          frontmatter: { title }\n        }\n      }\n    ) => {\n      const parts = slug.slice(1, -1).split('/');\n      let { items: prevItems } = accu;\n      for (const part of parts.slice(1, -1)) {\n        let tmp = prevItems.find(({ label }) => label === part);\n        if (tmp) {\n          if (!tmp.items) {\n            tmp.items = [];\n          }\n        } else {\n          tmp = { label: part, items: [] };\n          prevItems.push(tmp);\n        }\n        prevItems = tmp.items;\n      }\n      const existingItem = prevItems.find(({ label }) => label === parts[parts.length - 1]);\n      if (existingItem) {\n        existingItem.url = slug;\n        existingItem.title = title;\n      } else {\n        prevItems.push({\n          label: parts[parts.length - 1],\n          url: slug,\n          items: [],\n          title\n        });\n      }\n      return accu;\n    },\n    { items: [] }\n  );\n  return tree;\n\n};\n\n\nconst AboutPage = ({ data }, location) => {\n  const [treeData] = useState(() => {\n    return calculateTreeData(data.allMarkdownRemark.edges);\n  });\n\n  return (\n    <DocsLayout>\n      <article className={`post-content no-image`} >\n        <h1 className=\"post-title-docs\">Table Of Contents</h1>\n        <hr-title />\n        <div className=\"post-content-body tableOfContents\">\n          <ul>\n            {treeData.items.map(child => (\n              <li key={child.url}>\n                <a href={child.url}>{child.title}</a>\n                <ul>\n                  {child.items.map(item => (\n                    <li>\n                      <a href={item.url}>{item.title}</a>\n                    </li>\n                  ))}\n                </ul>\n              </li>\n            ))}\n          </ul>\n        </div>\n      </article>\n\n    </DocsLayout >\n  )\n}\n\nconst indexQuery = graphql`\n  query {\n    site {\n      siteMetadata {\n        title\n      }\n    }\n    allMarkdownRemark(filter: {fileAbsolutePath: {regex: \"/(docs)/\"  }}, sort: { fields: [fields___slug], order: ASC }) {\n      edges {\n        node {\n          fields {\n            slug\n          }\n          frontmatter {\n            title\n          }\n        }\n      }\n    }\n  }\n`\n\nexport default props => (\n  <StaticQuery\n    query={indexQuery}\n    render={data => (\n      <AboutPage location={props.location} data={data} {...props} />\n    )}\n  />\n)"],"sourceRoot":""}